name: Deploy Multi-Module to Synology NAS

on:
  push:
    branches: [ "production" ]
  pull_request:
    types: [closed]
    branches: [ "production" ]

jobs:

  check-changes:
    runs-on: ubuntu-latest
    outputs:
      config: ${{ steps.filter.outputs.config }}
      eureka: ${{ steps.filter.outputs.eureka }}
      user: ${{ steps.filter.outputs.user }}
      api-gateway: ${{ steps.filter.outputs.api-gateway }}
      auth: ${{ steps.filter.outputs.auth }}
      account: ${{ steps.filter.outputs.account }}
      product: ${{ steps.filter.outputs.product }}
      order: ${{ steps.filter.outputs.order }}
      common: ${{ steps.filter.outputs.common }}

    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            config: 'config-server/**'
            eureka: 'eureka-service/**'
            user: 'user-service/**'
            account: 'account-service/**'
            api-gateway: 'api-gateway/**'
            auth: 'auth-service/**'
            product: 'product-service/**'
            order: 'order-service/**'
            common: 'common/**'

  deploy-config:
    needs: check-changes
    if: ${{ needs.check-changes.outputs.config == 'true' || needs.check-changes.outputs.common == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Create Config Server Properties
        run: |
          mkdir -p config-server/src/main/resources

          echo "spring.application.name=ConfigServer" > config-server/src/main/resources/application.properties
          echo "spring.profiles.active=secret" >> config-server/src/main/resources/application.properties
          
          touch config-server/src/main/resources/application-secret.properties

          echo "ID=${{ secrets.ID }}" >> config-server/src/main/resources/application-secret.properties
          echo "PW=${{ secrets.PW }}" >> config-server/src/main/resources/application-secret.properties
          
          echo "server.port=${{ secrets.CONFIG_PORT }}" >> config-server/src/main/resources/application-secret.properties
          echo "spring.cloud.config.server.git.uri=${{ secrets.PRIVATE_GIT }}" >> config-server/src/main/resources/application-secret.properties
          echo "spring.cloud.config.server.git.ignoreLocalSshSettings=true" >> config-server/src/main/resources/application-secret.properties
          echo "spring.cloud.config.server.git.private-key=${{ secrets.PRIVATE_URL }}" >> config-server/src/main/resources/application-secret.properties
          
          ls -al config-server/src/main/resources/

      - name: Grant execute permission for Gradle
        run: chmod +x ./gradlew

      - name: Build Config Server
        run: ./gradlew clean :config-server:build -x test

      - name: Docker Build & Push
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          docker build -t ${{ secrets.DOCKER_USERNAME }}/config-server:latest ./config-server
          docker push ${{ secrets.DOCKER_USERNAME }}/config-server:latest

      - name: Deploy Config to NAS
        env:
          NAS_USERNAME: ${{ secrets.NAS_USERNAME }}
          NAS_PASSWORD: ${{ secrets.NAS_PASSWORD }}
          NAS_HOST: ${{ secrets.NAS_HOST }}
          SSH_PORT: ${{ secrets.NAS_SSH_PORT }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          CONFIG_PORT: ${{ secrets.CONFIG_PORT }}
        run: |
          sshpass -p "$NAS_PASSWORD" ssh -t -o StrictHostKeyChecking=no -p $SSH_PORT $NAS_USERNAME@$NAS_HOST << EOF
          
            export PATH=/usr/local/bin:\$PATH
            docker login -u $DOCKER_USERNAME -p $DOCKER_PASSWORD
            docker pull $DOCKER_USERNAME/config-server:latest
            docker stop config-server || true
            docker rm config-server || true
            docker run -d --name config-server -p $CONFIG_PORT:$CONFIG_PORT $DOCKER_USERNAME/config-server:latest
            exit
          EOF

  verify-config-server:
    needs: [deploy-config]
    if: always() && (needs.deploy-config.result == 'success' || needs.deploy-config.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Wait for Config Server Health (External Check)
        run: |
          echo "Checking Config Server Health from GitHub Runner (External)..."
          echo "Target: http://${{ secrets.NAS_HOST }}:${{ secrets.CONFIG_PORT }}/actuator/health"
          RETRIES=12
          COUNT=0
          while [ $COUNT -lt $RETRIES ]; do
            if curl -s -f -u "${{ secrets.ID }}:${{ secrets.PW }}" --connect-timeout 5 http://${{ secrets.NAS_HOST }}:${{ secrets.CONFIG_PORT }}/actuator/health > /dev/null; then
              echo "Config Server is UP and Healthy (Externally Accessible)!"
              exit 0
            fi
          
            echo "Waiting for Config Server... ($COUNT/$RETRIES)"
            sleep 10
            COUNT=$((COUNT+1))
          done
          
          echo "Config Server failed to respond to external requests."
          echo "Check Port Forwarding (Router) and Firewall (NAS)."
          exit 1

  deploy-eureka:
    needs: [check-changes, verify-config-server]
    if: needs.verify-config-server.result == 'success' && (contains(needs.check-changes.outputs.eureka, 'true') || contains(needs.check-changes.outputs.common, 'true'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Create Eureka Properties
        run: |
          mkdir -p eureka-service/src/main/resources
          
          echo "spring.application.name=eurekaServer" > eureka-service/src/main/resources/application.properties
          echo "spring.profiles.active=secret" >> eureka-service/src/main/resources/application.properties
          echo "server.port=\${EUREKA_PORT}" >> eureka-service/src/main/resources/application.properties
          echo "eureka.client.register-with-eureka=false" >> eureka-service/src/main/resources/application.properties
          echo "eureka.client.fetch-registry=false" >> eureka-service/src/main/resources/application.properties
          
          touch eureka-service/src/main/resources/application-secret.properties
          echo "ID=${{ secrets.ID }}" >> eureka-service/src/main/resources/application-secret.properties
          echo "PW=${{ secrets.PW }}" >> eureka-service/src/main/resources/application-secret.properties
          echo "EUREKA_PORT=${{ secrets.EUREKA_PORT }}" >> eureka-service/src/main/resources/application-secret.properties
          
          # 생성 확인
          ls -al eureka-service/src/main/resources/

      - name: Grant execute permission for Gradle
        run: chmod +x ./gradlew

      - name: Build Eureka Server
        run: ./gradlew clean :eureka-service:build -x test

      - name: Docker Build & Push
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          docker build -t ${{ secrets.DOCKER_USERNAME }}/eureka-service:latest ./eureka-service
          docker push ${{ secrets.DOCKER_USERNAME }}/eureka-service:latest

      - name: Deploy Eureka to NAS
        run: |
          sudo apt-get install -y sshpass
          sshpass -p "${{ secrets.NAS_PASSWORD }}" ssh -t -o StrictHostKeyChecking=no -p ${{ secrets.NAS_SSH_PORT }} ${{ secrets.NAS_USERNAME }}@${{ secrets.NAS_HOST }} << EOF
            export PATH=/usr/local/bin:\$PATH
            docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}
            docker pull ${{ secrets.DOCKER_USERNAME }}/eureka-service:latest
            docker stop eureka-service || true
            docker rm eureka-service || true
          
            docker run -d \
              --name eureka-service \
              -p ${{ secrets.EUREKA_PORT }}:${{ secrets.EUREKA_PORT }} \
              ${{ secrets.DOCKER_USERNAME }}/eureka-service:latest
          EOF
          
  deploy-api-gateway:
    needs: [check-changes, verify-config-server]
    if: needs.verify-config-server.result == 'success' && (contains(needs.check-changes.outputs.api-gateway, 'true') || contains(needs.check-changes.outputs.common, 'true'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Create Api-GateWay Properties
        run: |
          mkdir -p api-gateway/src/main/resources
          
          cat <<EOF > api-gateway/src/main/resources/bootstrap.yml
          spring:
            application:
              name: scg
            profiles:
              active: dev
            cloud:
              config:
                uri: http://${{ secrets.ID }}:${{ secrets.PW }}@${{ secrets.NAS_HOST }}:${{ secrets.CONFIG_PORT }}
                fail-fast: true

          eureka:
            client:
              register-with-eureka: true
              fetch-registry: true
              service-url:
                defaultZone: http://${{ secrets.ID }}:${{ secrets.PW }}@${{ secrets.NAS_HOST }}:${{ secrets.EUREKA_PORT }}/eureka/
          EOF

      - name: Grant execute permission for Gradle
        run: chmod +x ./gradlew

      - name: Build Api-GateWay Server
        run: ./gradlew clean :api-gateway:build -x test

      - name: Docker Build & Push
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          docker build -t ${{ secrets.DOCKER_USERNAME }}/api-gateway:latest ./api-gateway
          docker push ${{ secrets.DOCKER_USERNAME }}/api-gateway:latest

      - name: Deploy Api-GateWay to NAS
        run: |
          sudo apt-get install -y sshpass
          sshpass -p "${{ secrets.NAS_PASSWORD }}" ssh -t -o StrictHostKeyChecking=no -p ${{ secrets.NAS_SSH_PORT }} ${{ secrets.NAS_USERNAME }}@${{ secrets.NAS_HOST }} << EOF
            export PATH=/usr/local/bin:\$PATH
            docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}
            docker pull ${{ secrets.DOCKER_USERNAME }}/api-gateway:latest
            docker stop api-gateway || true
            docker rm api-gateway || true

            docker run -d \
              --name api-gateway \
              -p ${{ secrets.API_GATWAY_PORT }}:${{ secrets.API_GATWAY_PORT }} \
              ${{ secrets.DOCKER_USERNAME }}/api-gateway:latest
          EOF

  deploy-auth:
    needs: [ check-changes, verify-config-server ]
    if: needs.verify-config-server.result == 'success' && (contains(needs.check-changes.outputs.auth, 'true') || contains(needs.check-changes.outputs.common, 'true'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Create Auth Properties
        run: |
          mkdir -p auth-service/src/main/resources

          cat <<EOF > auth-service/src/main/resources/bootstrap.yml
          spring:
            application:
              name: auth
            profiles:
              active: dev
            cloud:
              config:
                uri: http://${{ secrets.ID }}:${{ secrets.PW }}@${{ secrets.NAS_HOST }}:${{ secrets.CONFIG_PORT }}
                fail-fast: true

          eureka:
            client:
              register-with-eureka: true
              fetch-registry: true
              service-url:
                defaultZone: http://${{ secrets.ID }}:${{ secrets.PW }}@${{ secrets.NAS_HOST }}:${{ secrets.EUREKA_PORT }}/eureka/
          EOF

      - name: Grant execute permission for Gradle
        run: chmod +x ./gradlew

      - name: Build Auth Server
        run: ./gradlew clean :auth-service:build -x test

      - name: Docker Build & Push
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          docker build -t ${{ secrets.DOCKER_USERNAME }}/auth-service:latest ./auth-service
          docker push ${{ secrets.DOCKER_USERNAME }}/auth-service:latest

      - name: Deploy Auth to NAS
        run: |
          sudo apt-get install -y sshpass
          sshpass -p "${{ secrets.NAS_PASSWORD }}" ssh -t -o StrictHostKeyChecking=no -p ${{ secrets.NAS_SSH_PORT }} ${{ secrets.NAS_USERNAME }}@${{ secrets.NAS_HOST }} << EOF
            export PATH=/usr/local/bin:\$PATH
            docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}
            docker pull ${{ secrets.DOCKER_USERNAME }}/auth-service:latest
            docker stop auth-service || true
            docker rm auth-service || true

            docker run -d \
              --name auth-service \
              -p ${{ secrets.AUTH_PORT }}:${{ secrets.AUTH_PORT }} \
              ${{ secrets.DOCKER_USERNAME }}/auth-service:latest
          EOF

  deploy-user:
    needs: [ check-changes, verify-config-server ]
    if: needs.verify-config-server.result == 'success' && (contains(needs.check-changes.outputs.user, 'true') || contains(needs.check-changes.outputs.common, 'true'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Create User Properties
        run: |
          mkdir -p user-service/src/main/resources

          cat <<EOF > user-service/src/main/resources/bootstrap.yml
          spring:
            application:
              name: user
            profiles:
              active: dev
            cloud:
              config:
                uri: http://${{ secrets.ID }}:${{ secrets.PW }}@${{ secrets.NAS_HOST }}:${{ secrets.CONFIG_PORT }}
                fail-fast: true

          eureka:
            client:
              register-with-eureka: true
              fetch-registry: true
              service-url:
                defaultZone: http://${{ secrets.ID }}:${{ secrets.PW }}@${{ secrets.NAS_HOST }}:${{ secrets.EUREKA_PORT }}/eureka/
          EOF

      - name: Grant execute permission for Gradle
        run: chmod +x ./gradlew

      - name: Build User Server
        run: ./gradlew clean :user-service:build -x test

      - name: Docker Build & Push
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          docker build -t ${{ secrets.DOCKER_USERNAME }}/user-service:latest ./user-service
          docker push ${{ secrets.DOCKER_USERNAME }}/user-service:latest

      - name: Deploy User to NAS
        run: |
          sudo apt-get install -y sshpass
          sshpass -p "${{ secrets.NAS_PASSWORD }}" ssh -t -o StrictHostKeyChecking=no -p ${{ secrets.NAS_SSH_PORT }} ${{ secrets.NAS_USERNAME }}@${{ secrets.NAS_HOST }} << EOF
            export PATH=/usr/local/bin:\$PATH
            docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}
            docker pull ${{ secrets.DOCKER_USERNAME }}/user-service:latest
            docker stop user-service || true
            docker rm user-service || true

            docker run -d \
              --name user-service \
              -p ${{ secrets.USER_PORT }}:${{ secrets.USER_PORT }} \
              ${{ secrets.DOCKER_USERNAME }}/user-service:latest
          EOF

  deploy-product:
    needs: [ check-changes, verify-config-server ]
    if: needs.verify-config-server.result == 'success' && (contains(needs.check-changes.outputs.product, 'true') || contains(needs.check-changes.outputs.common, 'true'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Create Product Properties & Logback
        run: |
          mkdir -p product-service/src/main/resources
          
          # 1. bootstrap.yml 생성
          cat <<EOF > product-service/src/main/resources/bootstrap.yml
          spring:
            application:
              name: product
            profiles:
              active: dev
            cloud:
              config:
                uri: http://${{ secrets.ID }}:${{ secrets.PW }}@${{ secrets.NAS_HOST }}:${{ secrets.CONFIG_PORT }}
                fail-fast: true
          
            servlet:
              multipart:
                enabled: true
                file-size-threshold: 0B
                max-file-size: 100MB
                max-request-size: 100MB
                location: /app/images 
          
          eureka:
            client:
              register-with-eureka: true
              fetch-registry: true
              service-url:
                defaultZone: http://${{ secrets.ID }}:${{ secrets.PW }}@${{ secrets.NAS_HOST }}:${{ secrets.EUREKA_PORT }}/eureka/
          EOF
          
          touch product-service/src/main/resources/application-secret.properties
          echo "FILE_UPLOAD_PATH=/app/images/" >> product-service/src/main/resources/application-secret.properties
          echo "ACCOUNT_SERVER_URL=http://account-service:8080/account/api" >> product-service/src/main/resources/application-secret.properties

      - name: Grant execute permission for Gradle
        run: chmod +x ./gradlew

      - name: Build Product Server
        run: ./gradlew clean :product-service:build -x test

      - name: Docker Build & Push
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          docker build -t ${{ secrets.DOCKER_USERNAME }}/product-service:latest ./product-service
          docker push ${{ secrets.DOCKER_USERNAME }}/product-service:latest

      - name: Deploy Product to NAS
        run: |
          sudo apt-get install -y sshpass
          sshpass -p "${{ secrets.NAS_PASSWORD }}" ssh -t -o StrictHostKeyChecking=no -p ${{ secrets.NAS_SSH_PORT }} ${{ secrets.NAS_USERNAME }}@${{ secrets.NAS_HOST }} << EOF
            export PATH=/usr/local/bin:\$PATH
            docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}
            docker pull ${{ secrets.DOCKER_USERNAME }}/product-service:latest
            docker stop product-service || true
            docker rm product-service || true

            docker run -d \
              --name product-service \
              -p ${{ secrets.PRODUCT_PORT }}:${{ secrets.PRODUCT_PORT }} \
              -v /volume1/docker/msa/product/logs:/app/logs \
              -v /volume1/docker/msa/product/images:/app/images \
              ${{ secrets.DOCKER_USERNAME }}/product-service:latest
          EOF